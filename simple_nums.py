# Найти все простые числа меньше или равные заданному числу N.

#число должно делиться только на 1 и на само себя 

N = 81

def simple_num(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        print(f'Берем {i} для {n}')
        if n % i == 0:
            print(f'Остаток по модулю числа {n} при делении на {i} равен 0, число не подходит')
            return False
    return True

#Добавляем в генератор все простые числа в рейндже от 2 до н при выполнении условия функции simple_num
numerate = [x for x in range(2, N+1) if simple_num(x)]

print(numerate)



# Создаем генератор списка numerate который будет добавлять в список от 2(чтобы сразу включить простое число 2), до N+1 (чтобы включить в проверку само число) на условие simple_num(x).
# В функции simple_num, в цикле проверяем диапазон от 2 до корня числа(корень потому, что один из делителей всегда меньше или равен корню из N), если будет пустой диапазон (2, 2), цикл не выполнится и генератор просто добавит число в список.
# В условии if n%0 проверяем остаток от деления, ждем что он будет больше 0 (для простого числа)
# Выводим сгенерированный список простых чисел.

# Про временную сложность алгоритма:
# Проверяем каждое число от 2 до N - O(N) на то простое оно или нет
# И каждое это число(корень этого числа) мы проверяем на делители O(√N)
# Будет примерно вот такая временная сложность O(N) * O(√N)  = O(N^(1.5))
